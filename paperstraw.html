<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Straw</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
            width: 100vw !important;
            height: 100vh !important;
        }
        
        #file-input {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        
        #file-input input {
            margin-top: 5px;
        }
        
        #file-input label {
            font-size: 12px;
        }
    </style>
	</head>
	<body>
    <div id="file-input">
        <label for="texture-file">Load texture:</label><br>
        <input type="file" id="texture-file" accept="image/*">
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 1000);
		camera.position.set(20, 3, 5);
		var renderer = new THREE.WebGLRenderer({
			antialias: true
		});
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setClearColor(0x666666);
		document.body.appendChild(renderer.domElement);

		var controls = new THREE.OrbitControls(camera, renderer.domElement);

		var light = new THREE.DirectionalLight(0xffffff, 0.5);
		light.position.set(1, 1, 1);
		scene.add(light);
		scene.add(new THREE.AmbientLight(0xffffff, 0.5));

		var paperLength = 28.5;
		var diameter = 0.8;
		
		var circumference = Math.PI * diameter;
		var numberOfTurns = paperLength / circumference * 0.707;
		var turnLength = circumference / Math.cos(Math.PI / 4);
		
		console.log(turnLength);

		var rbnWidth = turnLength;
		var rbnSteps = numberOfTurns;
		var rbnStepLength = turnLength;
		var rbnSegsPerStep = 80;
		var rbnRadius = diameter;

		var rbnGeom = new THREE.PlaneGeometry(rbnSteps * Math.PI * 2, rbnWidth, rbnSteps * rbnSegsPerStep, 1);
		rbnGeom.computeBoundingBox();
		var size = new THREE.Vector3();
		rbnGeom.boundingBox.getSize(size);
		rbnGeom.translate(size.x * 0.5, size.y * 0.5, size.z * 0.5);

		rbnGeom.vertices.forEach(v => {
			let angle = -v.x;
			let radius = rbnRadius + v.z;
			let shift = (v.x / (Math.PI * 2)) * rbnStepLength + v.y;
			  
			v.x = Math.cos(angle) * radius;
			v.y = shift;
			v.z = Math.sin(angle) * radius;
		});
		
		const rotationAngleDegrees = -2.5;
		const rotationAngle = rotationAngleDegrees * (Math.PI / 180);
		
		console.log("angle " + rotationAngle);
		
		rbnGeom.faceVertexUvs[0].forEach(uvs => {
			uvs.forEach(uv => {
				let originalU = uv.x;
				let originalV = uv.y;
				uv.x = originalU * Math.cos(rotationAngle) - originalV * Math.sin(rotationAngle);
				uv.y = originalU * Math.sin(rotationAngle) + originalV * Math.cos(rotationAngle);
			});
		});

		rbnGeom.computeFaceNormals();
		rbnGeom.computeVertexNormals();
		rbnGeom.center();

		const ribbonMaterial = new THREE.MeshStandardMaterial({
			color: 0xffffff,
			side: THREE.DoubleSide
		});

		const ribbon = new THREE.Mesh(rbnGeom, ribbonMaterial);
		scene.add(ribbon);

        document.getElementById('texture-file').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        const texture = new THREE.Texture(img);
                        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.RepeatWrapping;
                        texture.needsUpdate = true;
                        
                        ribbonMaterial.map = texture;
                        ribbonMaterial.needsUpdate = true;
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        controls.enableRotate = false;
        controls.enableZoom = false;
        controls.enablePan = false;

        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        renderer.domElement.addEventListener('mousedown', onMouseDown, false);
        renderer.domElement.addEventListener('mousemove', onMouseMove, false);
        renderer.domElement.addEventListener('mouseup', onMouseUp, false);
		renderer.domElement.addEventListener('wheel', onMouseWheel, false);

        function onMouseDown(event) {
            mouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (mouseDown) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;

                ribbon.rotation.y += deltaX * 0.01;
                //ribbon.rotation.z += deltaY * 0.01;

                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }

        function onMouseUp() {
            mouseDown = false;
        }
		
		function onMouseWheel(event) {
            const delta = -event.deltaY * 0.001;
            ribbon.scale.addScalar(delta);
        }

        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        render();

		function render() {
			requestAnimationFrame(render);
			renderer.render(scene, camera);
		}
    </script>
</body>
</html>